package com.sist.exception;
/* <문제3>
 * final 클래스 => 종단 클래스 (java.lang)
 * ----------- 확장을 할 수 없다(있는 그대로) => 상속을 내리지 못한다 => 상위클래스가 될 수 없다
 * java.lang
 * java.util
 * java.io
 * java.net
 * java.text
 * ----------- 기본 라이브러리
 * java.sql, javax.http.servlet.* javax.xml...
 * 오라클      브라우저
 * 
 * <문제4>
 * 오버라이딩(상속의 기본) => 변경해서 사용 (다형성)
 *   객체지향의 3대 요소
 *    1. 데이터 보호 목적
 *       캡슐화: 변수를 은닉화 => 메소드를 통해서 접근이 가능하게 만든다
 *             -----------                ---------
 *              private                    public
 *            => 변수는 2가지 기능만 수행
 *               : 메모리 저장(setter) / 메모리에서 데이터 읽기(getter)
 *            => 모든 멤버변수: private
 *            => 모든 메소드(생성자): public => 다른 클래스와 연결 가능하게 만들어줌
 *       접근지정어
 *       --------
 *       1) private: 자신의 클래스에서만 사용이 가능(은닉화)
 *                   다른 클래스에서는 접근이 불가능
 *       2) default: 같은 패키지에서만 접근이 가능
 *       3) public: 공개(패키지 상관없이 모든 클래스에 접근이 가능)
 *       
 *    2. 재사용 목적 : 상속, 포함 => 클래스 크기 결정 => 형변환
 *       - 상속 : 변경해서 사용하고 싶다
 *       class A
 *       class B extends A => A가 가지고 있는 모든 내용을 가지고 온다
 *               ------- A의 내용을 변경해서 사용,추가가 가능하다
 *                       라이브러리 => 프로그램에 맞지 않는 경우 (수정)
 *       =====> A(상속을 내리는 클래스) > B(상속을 받는 클래스)
 *        => A a=new A();
 *           B b=new B();
 *           A c=new B(); => 묵시적 형변환 (자동)
 *           ====> 추상클래스/인터페이스(메모리 할당이 안된다) => 메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다
 *                 미완성 클래스(메소드가 구현이 안 된 상태)
 *                 사용 예) 설계, 같은 기능이지만 처리를 프로그램에 맞게 할 때(버튼 클릭,마우스 클릭...)
 *           B d=(B)c; => 명시적 형변환 (강제)
 *           --------- 라이브러리에서 많이 사용
 *           => 클래스를 저장해서 관리(클래스) => Collection
 *              'A'
 *       - 포함 : 있는 그대로 사용하고 싶다                
 *       class A
 *       {
 *          B b=new B(); // 특별한 경우가 아니면 재정의하지 않는다
 *       }
 *       class B
 *    3. 수정, 추가 목적(유지보수)
 *       수정(오버라이딩) 추가(오버로딩) => 메소드 관련
 *       
 *       ---------------------------------------------
 *                     오버로딩           오버라이딩
 *       ---------------------------------------------
 *        관계       한개의 클래스       상속관계
 *                  상속 관계
 *       ---------------------------------------------
 *        메소드명    동일              동일
 *       ---------------------------------------------
 *        매개변수    갯수나             동일
 *                  데이터형이 다르다
 *       ---------------------------------------------
 *        리턴형      관계없음           동일
 *       ---------------------------------------------
 *        접근지정어   관계없음           확장가능
 *       ---------------------------------------------
 *        사용처      생성자            인터페이스/추상클래스
 *       ---------------------------------------------
 *       ***상속
 *       1) 호출 ==> 상위클래스의 생성자가 먼저 호출 (기본생성자)
 *          class A
 *          {
 *             => public A(){}
 *             public A(int a){}
 *          }
 *          class B
 *          {
 *             public B(int a,int b){}
 *          }
 *          B b=new B();
 *          new A() new B()
 *       2) 상속 예외조건 : static, 생성자, 초기화블록, private
 *       
 * 클래스의 종류
 * = 추상클래스
 * = 인터페이스 : 추상클래스의 단점을 보완(클래스와 동일하게 취급)
 *   *** 클래스(단일) / 인터페이스(다중)
 *   --- 설계도(구현이 안 된 상태) => 미완성 클래스 (자신이 메모리 할당을 할 수 없다)
 *   --- 여러 개의 관련된 클래스를 모아서 한 개의 객체명으로 제어
 *   ----------------------------------------------------
 *                 추상클래스            인터페이스
 *   ----------------------------------------------------
 *   상속관계        단일 상속             다중 상속
 *   ----------------------------------------------------
 *   상속키워드       extends           implements
 *   ----------------------------------------------------
 *   멤버변수        인스턴스변수        상수형 변수만 사용      => 인스턴스변수와 정적변수는 초기화를 해야하기 때문에 생성자 필요
 *                  정적변수                                 상수형 변수는 명시적 초기화를 하므로 생성자 불필요
 *   ----------------------------------------------------
 *   메소드         구현된 메소드        구현이 안된 메소드
 *               구현이 안된 메소드
 *   ----------------------------------------------------
 *   기법           오버라이딩            오버라이딩
 *   ----------------------------------------------------
 *   형식
 *   - 추상클래스
 *     [접근지정어] abstract class ClassName
 *     {
 *       -----------------------------------------------
 *        변수
 *         인스턴스 변수
 *         static 변수
 *       -----------------------------------------------
 *        메소드
 *         구현된 메소드
 *         [접근지정어] 리턴형 메소드명(매개변수..)
 *         {
 *         }
 *         구현이 안된 메소드(선언만)
 *         [접근지정어] abstract 리턴형 메소드명(매개변수..);
 *                   ---------
 *       -----------------------------------------------
 *        생성자, 오버로딩이 가능
 *       -----------------------------------------------
 *      }
 *      
 *    - 인터페이스
 *      [접근지정어] interface Interface명
 *      {
 *        -------------------------------------
 *         변수선언(상수형변수)
 *           int a=10; => 값을 명시적으로 지정
 *           => public static final int a=10;
 *        -------------------------------------
 *         구현이 안된 메소드 목록
 *          void display();
 *          => public abstract void display();
 *        -------------------------------------
 *         구현한 메소드 목록
 *          default void aaa(){}
 *          => public default void aaa(){}
 *          static void bbb(){}
 *          => public static void bbb(){}
 *        -------------------------------------
 *      }
 *     =====> 인터페이스는 변수나 메소드가 public
 *            인터페이스는 연결목적을 가지고 있으므로 언제든 연결이 가능해야 한다
 *  -------------------------------------------------------------------
 *  - 상속
 *  interface   =========>   interface
 *               extends
 *  interface   =========>   class
 *              implements
 *              
 *  - 다중상속
 *  class A implements 인터페이스, 인터페이스...
 *      
 *       
 * 
 */
import java.util.*;
class AAA
{
	public void aaa() {}
	public AAA() {}
	int a=10;
}
abstract class C
{
	C(){}
	C(int a){}
}
class A
{
	int a=10;
	String name="홍길동";
	public A(){}
	public A(int a) {
		this.a=a;
	}
}
// new A() 
class B extends A
{
	int b=20;
	public B()
	{
		super(); // 상위클래스의 생성자를 호출
	}
}
// A a=new B() ==> A에 있는 데이터만 사용, 메소드는 변경된 것만 사용
// 하위클래스에서 추가된 메소드와 변수를 사용할 수 없다
// B b=new B()
public class 정리_7장 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		List list=new ArrayList();
//		list.add(new 정리_7장()); // add안에 있는 ()는 Object
//		String s=(String)list.get(0); // Object를 String으로 변환해야한다
		
//		String s1="Hello";
//		String s2="Hello";
//		String s3=new String("Hello");
//		
//		if(s1==s2)
//			System.out.println("같다(참조주소)");
		
		Object o=new AAA();
	//object가 선언됐으므로 aaa가 갖고 있는 걸 가져오는 게 아니라 object에 있는 거만 사용
	//선언된 클래스만 가져올 수 있다(object)
	}

}
